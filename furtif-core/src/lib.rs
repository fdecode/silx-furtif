// This program is free software: you can redistribute it and/or modify
// it under the terms of the Lesser GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// Lesser GNU General Public License for more details.

// You should have received a copy of the Lesser GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Copyright 2024 Frederic Dambreville, Jean Dezert Developers.


//! This is part of [**Furtif**](https://github.com/fdecode/silx-furtif) project  
//! 
//! `furtif-core` contains core components for implementing furtif application  
//! 
//! # Purpose
//! Furtif offers a generic implementation in Rust of functionalities for manipulating belief functions and merging them. 
//! This crate includes:
//! * Traits defining the notion of lattice and its variants
//!   * Two types two lattices are implemented
//!     * Powerset
//!     * Taxonomy
//! * Tools for transforming between different forms of belief functions
//! * The notion of referee functions is implemented, thus enabling:
//!   * the ability to generically define fusion rules
//!   * the design of generic engines for computing fused assignments
//!     * Presently, an exact computation method with pruning is proposed  
//! 
//! Furtif is designed from the outset to operate asynchronously, interacting with the Silx library  
//! 
//! Furtif remains a project under development. 
//! The current version is closely linked to the Silx crate, since our aim was to integrate Furtif into an asynchronous environment. 
//! Further enhancements are envisaged, such as a Silx-independent version, or the implementation of Mex modules for Matlab or Octave. 
//! In addition, we have some developments in view concerning belief functions. 
//! 
//! To start with, the following example gives a minimalist overview of the library's features.
//! Other examples are also available on the project's github.
//! 
//! # Minimalist example (Dempster-Shafer fusion)
//! ## Cargo.toml
//! ```toml
//! [package]
//! name = "silx_furtif_dst"
//! version = "0.1.0"
//! edition = "2021"
//! 
//! [dependencies]
//! furtif-core = "^0.1.0"
//! ```
//! ## main.rs
//! ```
//! use furtif_core::{
//!     structs::{DiscountedFuser, EnumRule, Powerset},
//!     traits::{ComplementedLattice, DiscountedFusion, IterableLattice, Lattice},
//! };
//! 
//! /// Furtif: a simple fusion of 2 masses by Dempster-Shafer rule 
//! pub fn main() -> Result<(),String> {
//!     // build a powerset generated by `A` `B` and `C`
//!     let powerset = Powerset::new_with_label(
//!         &["A".to_string(), "B".to_string(), "C".to_string()], 128
//!     )?;
//!     // List of elements in the powerset (non-decreasing for the inclusion ordering)
//!     println!("==== Elements -------------");
//!     let powerset = powerset.set_iterators();
//!     for e in powerset.bottom_to_top()? {
//!         println!("{e} -> {}", powerset.to_string(&e)?);
//!     }
//!     // Some boolean operations and results
//!     // * `powerset.join(...)` is the disjunction operator
//!     // * `powerset.not(...)` is the boolean negation
//!     // * `powerset.meet(...)` is the conjunction operator
//!     println!("\n==== operators -------------");
//!     let a = powerset.from_str("A")?;
//!     let b = powerset.from_str("B")?;
//!     let aub = powerset.join(&a,&b)?;
//!     let not_a = powerset.not(&a)?;
//!     let aub_n_not_a = powerset.meet(&aub, &not_a)?;
//!     println!("aub: {} -> {}", aub, powerset.to_string(&aub)?);
//!     println!("not_a: {} -> {}", not_a, powerset.to_string(&not_a)?);
//!     println!("aub_n_not_a: {} -> {}", aub_n_not_a, powerset.to_string(&aub_n_not_a)?);
//!     println!("\n==== assignments -------------");
//!     // Construction of two basic belief assignments
//!     let c = powerset.from_str("C")?;
//!     let buc = not_a;
//!     let cua = powerset.not(&b)?;
//!     let m1 = powerset.assignment()
//!         + (a, 3.0) + (aub, 3.0) + (buc, 4.0) + ();
//!     let m2 = powerset.assignment()
//!         + (c, 2.0) + (aub, 3.0) + (cua, 5.0) + ();
//!     println!("m1 -> {m1}");
//!     println!("m2 -> {m2}");
//!     // Computation of Dempster-Shafer fusion
//!     let engine = DiscountedFuser::new(512..=1024);
//!     let (fused,z) = engine.fuse(&powerset, &EnumRule::DempsterShafer,&[&m1,&m2])?;
//!     println!("fused / DS -> {fused}");
//!     println!("z -> {z:.3}");
//!     Ok(())
//! }
//! ```
//! ## Typical output
//! ```txt
//! ==== Elements -------------
//! 0 -> ⊥
//! 4 -> C
//! 1 -> A
//! 2 -> B
//! 5 -> A | C
//! 6 -> B | C
//! 3 -> A | B
//! 7 -> ⊤
//! 
//! ==== operators -------------
//! aub: 3 -> A | B
//! not_a: 6 -> B | C
//! aub_n_not_a: 2 -> B
//! 
//! ==== assignments -------------
//! m1 -> [ 6 -> 0.4000, 3 -> 0.3000, 1 -> 0.3000, ]
//! m2 -> [ 3 -> 0.3000, 5 -> 0.5000, 4 -> 0.2000, ]
//! fused / DS -> [ 3 -> 0.1023, 4 -> 0.3182, 1 -> 0.4432, 2 -> 0.1364, ]
//! z -> 0.120
//! ```


/// Trait definitions
pub mod traits; 
/// Struct and Enum definitions
pub mod structs;